<!DOCTYPE html>
<html>

<!-- Mirrored from www.cplusplus.com/doc/tutorial/functions/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Jul 2021 12:46:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Functions - C++ Tutorials</title>
<link rel="canonical" href="index.html">
<link rel="shortcut icon" type="image/x-icon" href="https://www.cplusplus.com/favicon.ico">
<link rel="stylesheet" type="text/css" href="https://www.cplusplus.com/v322/main.css">
<script src="https://www.cplusplus.com/v322/main.js" type="text/javascript"></script>
<script async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script>
<script>
  window.googletag = window.googletag || {cmd: []};
  googletag.cmd.push(function() {
    googletag.defineSlot('/147246189/cplusplus.com_728x90_leaderboard_1', [728, 90], 'div-gpt-ad-1593433023017-0').addService(googletag.pubads());
    googletag.defineSlot('/147246189/cplusplus.com_234x120_sidebar_1', [234, 60], 'cplusplus.com_234x120_sidebar_1').addService(googletag.pubads());
    googletag.pubads().enableSingleRequest();
    googletag.pubads().disableInitialLoad();
    googletag.enableServices();
  });
</script>
<script src="https://cloud.setupad.com/hb/cpluspluscom.js" async></script>
<script src="https://c.aaxads.com/aax.js?pub=AAX5H4CNQ&amp;hst=www.cplusplus.com&amp;ver=1.2" async></script></head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="https://www.cplusplus.com/" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="https://www.cplusplus.com/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="https://www.cplusplus.com/doc/">Tutorials</a></li>
<li><a href="../index.html">C++ Language</a></li>
<li class="here">Functions</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div class="C_support">
<div id='div-gpt-ad-1593433023017-0' style='width: 728px; height: 90px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1593433023017-0'); });
  </script>
</div>
</div><div id="I_content">
<div class="C_doc">
<h1>Functions</h1>
<section id="functions">
Functions allow to structure programs in segments of code to perform individual tasks.<br>
<br>
In C++, a function is a group of statements that is given a name, and which can be called from some point of the program. The most common syntax to define a function is:<br>
<br>
<code>
type name ( parameter1, parameter2, ...) { statements }<br>
</code>
<br>
Where:<br>
- <code>type</code> is the type of the value returned by the function.<br>
- <code>name</code> is the identifier by which the function can be called.<br>
- <code>parameters</code> (as many as needed): Each parameter consists of a type followed by an identifier, with each parameter being separated from the next by a comma. Each parameter looks very much like a regular variable declaration (for example: <code>int x</code>), and in fact acts within the function as a regular variable which is local to the function. The purpose of parameters is to allow passing arguments to the function from the location where it is called from.<br>
- <code>statements</code> is the function's body. It is a block of statements surrounded by braces { } that specify what the function actually does.<br>
<br>
Let's have a look at an example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// function example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> addition (<var>int</var> a, <var>int</var> b)
{
  <var>int</var> r;
  r=a+b;
  <var>return</var> r;
}

<var>int</var> main ()
{
  <var>int</var> z;
  z = addition (5,3);
  cout &lt;&lt; <kbd>"The result is "</kbd> &lt;&lt; z;
}</code></pre></td>
<td class="output"><pre><samp>The result is 8</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This program is divided in two functions: <code>addition</code> and <code>main</code>. Remember that no matter the order in which they are defined, a C++ program always starts by calling <code>main</code>. In fact, <code>main</code> is the only function called automatically, and the code in any other function is only executed if its function is called from <code>main</code> (directly or indirectly).<br>
<br>
In the example above, <code>main</code> begins by declaring the variable <code>z</code> of type <code>int</code>, and right after that, it performs the first function call: it calls <code>addition</code>. The call to a function follows a structure very similar to its declaration. In the example above, the call to <code>addition</code> can be compared to its definition just a few lines earlier:<br>
<br>
<img src="function_arguments.png" alt="">
 <br>
The parameters in the function declaration have a clear correspondence to the arguments passed in the function call. The call passes two values, <code>5</code> and <code>3</code>, to the function; these correspond to the parameters <code>a</code> and <code>b</Code>, declared for function <code>addition</code>.<br>
<br>
At the point at which the function is called from within main, the control is passed to function <code>addition</code>: here, execution of <code>main</code> is stopped, and will only resume once the <code>addition</code> function ends. At the moment of the function call, the value of both arguments (<code>5</code> and <code>3</code>) are copied to the local variables <code>int a</code> and <code>int b</code> within the function.<br>
<br>
Then, inside <code>addition</code>, another local variable is declared (<code>int r</code>), and by means of the expression <code>r=a+b</code>, the result of <code>a</code> plus <code>b</code> is assigned to <code>r</code>; which, for this case, where <code>a</code> is 5 and <code>b</code> is 3, means that 8 is assigned to <code>r</code>.<br>
<br>
The final statement within the function:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>return</var> r;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Ends function <code>addition</code>, and returns the control back to the point where the function was called; in this case: to function <code>main</code>. At this precise moment, the program resumes its course on <code>main</code> returning exactly at the same point at which it was interrupted by the call to <code>addition</code>. But additionally, because <code>addition</code> has a return type, the call is evaluated as having a value, and this value is the value specified in the return statement that ended <code>addition</code>: in this particular case, the value of the local variable <code>r</code>, which at the moment of the <code>return</code> statement had a value of 8.<br>
<br>
<img src="function_return_value.png" alt="">
<br>
Therefore, the call to <code>addition</code> is an expression with the value returned by the function, and in this case, that value, 8, is assigned to <code>z</code>. It is as if the entire function call (<code>addition(5,3)</code>) was replaced by the value it returns (i.e., 8).<br>
<br>
Then main simply prints this value by calling: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The result is "</kbd> &lt;&lt; z;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
A function can actually be called multiple times within a program, and its argument is naturally not limited just to literals:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// function example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> subtraction (<var>int</var> a, <var>int</var> b)
{
  <var>int</var> r;
  r=a-b;
  <var>return</var> r;
}

<var>int</var> main ()
{
  <var>int</var> x=5, y=3, z;
  z = subtraction (7,2);
  cout &lt;&lt; <kbd>"The first result is "</kbd> &lt;&lt; z &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"The second result is "</kbd> &lt;&lt; subtraction (7,2) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"The third result is "</kbd> &lt;&lt; subtraction (x,y) &lt;&lt; <kbd>'\n'</kbd>;
  z= 4 + subtraction (x,y);
  cout &lt;&lt; <kbd>"The fourth result is "</kbd> &lt;&lt; z &lt;&lt; <kbd>'\n'</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>The first result is 5
The second result is 5
The third result is 2
The fourth result is 6</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Similar to the <code>addition</code> function in the previous example, this example defines a <code>subtract</code> function, that simply returns the difference between its two parameters. This time, <code>main</code> calls this function several times, demonstrating more possible ways in which a function can be called.<br>
<br>
Let's examine each of these calls, bearing in mind that each function call is itself an expression that is evaluated as the value it returns. Again, you can think of it as if the function call was itself replaced by the returned value:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>z = subtraction (7,2);
cout &lt;&lt; <kbd>"The first result is "</kbd> &lt;&lt; z;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If we replace the function call by the value it returns (i.e., 5), we would have:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>z = 5;
cout &lt;&lt; <kbd>"The first result is "</kbd> &lt;&lt; z;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
With the same procedure, we could interpret:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The second result is "</kbd> &lt;&lt; subtraction (7,2);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
as:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The second result is "</kbd> &lt;&lt; 5;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
since 5 is the value returned by <code>subtraction (7,2)</code>.<br>
<br>
In the case of:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The third result is "</kbd> &lt;&lt; subtraction (x,y);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
 <br>
The arguments passed to subtraction are variables instead of literals. That is also valid, and works fine. The function is called with the values <code>x</code> and <code>y</code> have at the moment of the call: 5 and 3 respectively, returning 2 as result. <br>
<br>
The fourth call is again similar:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>z = 4 + subtraction (x,y);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The only addition being that now the function call is also an operand of an addition operation. Again, the result is the same as if the function call was replaced by its result: 6. Note, that thanks to the commutative property of additions, the above can also be written as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>z = subtraction (x,y) + 4;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
With exactly the same result. Note also that the semicolon does not necessarily go after the function call, but, as always, at the end of the whole statement. Again, the logic behind may be easily seen again by replacing the function calls by their returned value:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>z = 4 + 2;    <cite>// same as z = 4 + subtraction (x,y);</cite>
z = 2 + 4;    <cite>// same as z = subtraction (x,y) + 4; </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="void">
<h3>Functions with no type. The use of void</h3>
The syntax shown above for functions:<br>
<br>
<code>
type name ( argument1, argument2 ...) { statements }<br>
</code>
<br>
Requires the declaration to begin with a type. This is the type of the value returned by the function. But what if the function does not need to return a value? In this case, the type to be used is <code>void</code>, which is a special type to represent the absence of value. For example, a function that simply prints a message may not need to return any value:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br></code></pre></td>
<td class="source"><pre><code><cite>// void function example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> printmessage ()
{
  cout &lt;&lt; <kbd>"I'm a function!"</kbd>;
}

<var>int</var> main ()
{
  printmessage ();
}</code></pre></td>
<td class="output"><pre><samp>I'm a function!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>void</code> can also be used in the function's parameter list to explicitly specify that the function takes no actual parameters when called. For example, <code>printmessage</code> could have been declared as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>void</var> printmessage (<var>void</var>)
{
  cout &lt;&lt; <kbd>"I'm a function!"</kbd>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In C++, an empty parameter list can be used instead of <code>void</code> with same meaning, but the use of <code>void</code> in the argument list was popularized by the C language, where this is a requirement.<br>
<br>
Something that in no case is optional are the parentheses that follow the function name, neither in its declaration nor when calling it. And even when the function takes no parameters, at least an empty pair of parentheses shall always be appended to the function name. See how <code>printmessage</code> was called in an earlier example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>printmessage ();</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The parentheses are what differentiate functions from other kinds of declarations or statements. The following would not call the function:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>printmessage;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="mainreturns">
<h3>The return value of main</h3>
You may have noticed that the return type of <code>main</code> is <code>int</code>, but most examples in this and earlier chapters did not actually return any value from <code>main</code>.<br>
<br>
Well, there is a catch: If the execution of <code>main</code> ends normally without encountering a <code>return</code> statement the compiler assumes the function ends with an implicit return statement:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>return</var> 0;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that this only applies to function <code>main</code> for historical reasons. All other functions with a return type shall end with a proper <code>return</code> statement that includes a return value, even if this is never used.<br>
<br>
When <code>main</code> returns zero (either implicitly or explicitly), it is interpreted by the environment as that the program ended successfully. Other values may be returned by <code>main</code>, and some environments give access to that value to the caller in some way, although this behavior is not required nor necessarily portable between platforms. The values for <code>main</code> that are guaranteed to be interpreted in the same way on all platforms are:<br>
<br>
<table class="boxed">
<tr><th>value</th><th>description</th></tr>
<tr><td><code>0</code></td><td>The program was successful</td></tr>
<tr><td><code><a href="https://www.cplusplus.com/EXIT_SUCCESS">EXIT_SUCCESS</a></code></td><td>The program was successful (same as above).<br>
This value is defined in header <code><a href="https://www.cplusplus.com/<cstdlib>">&lt;cstdlib&gt;</a></code>.</td></tr>
<tr><td><code><a href="https://www.cplusplus.com/EXIT_FAILURE">EXIT_FAILURE</a></code></td><td>The program failed.<br>
This value is defined in header <code><a href="https://www.cplusplus.com/<cstdlib>">&lt;cstdlib&gt;</a></code>.</td></tr>
</table>
<br>
Because the implicit <code>return 0;</code> statement for <code>main</code> is a tricky exception, some authors consider it good practice to explicitly write the statement.<br>
</section>
<br>
<section id="reference">
<h3>Arguments passed by value and by reference</h3>
In the functions seen earlier, arguments have always been passed <i>by value</i>. This means that, when calling a function, what is passed to the function are the values of these arguments on the moment of the call, which are copied into the variables represented by the function parameters. For example, take:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> x=5, y=3, z;
z = addition ( x, y );</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, function addition is passed 5 and 3, which are copies of the values of <code>x</code> and <code>y</code>, respectively. These values (5 and 3) are used to initialize the variables set as parameters in the function's definition, but any modification of these variables within the function has no effect on the values of the variables x and y outside it, because x and y were themselves not passed to the function on the call, but only copies of their values at that moment.<br>
<br>
<img src="function_arguments.png" alt="">
<br>
In certain cases, though, it may be useful to access an external variable from within a function. To do that, arguments can be passed <i>by reference</i>, instead of <i>by value</i>. For example, the function <code>duplicate</code> in this code duplicates the value of its three arguments, causing the variables used as arguments to actually be modified by the call:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><cite>// passing parameters by reference</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> duplicate (<var>int</var>&amp; a, <var>int</var>&amp; b, <var>int</var>&amp; c)
{
  a*=2;
  b*=2;
  c*=2;
}

<var>int</var> main ()
{
  <var>int</var> x=1, y=3, z=7;
  duplicate (x, y, z);
  cout &lt;&lt; <kbd>"x="</kbd> &lt;&lt; x &lt;&lt; <kbd>", y="</kbd> &lt;&lt; y &lt;&lt; <kbd>", z="</kbd> &lt;&lt; z;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>x=2, y=6, z=14</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
To gain access to its arguments, the function declares its parameters as <i>references</i>. In C++, references are indicated with an ampersand (<code>&</code>) following the parameter type, as in the parameters taken by <code>duplicate</code> in the example above.<br>
<br>
When a variable is passed <i>by reference</i>, what is passed is no longer a copy, but the variable itself, the variable identified by the function parameter, becomes somehow associated with the argument passed to the function, and any modification on their corresponding local variables within the function are reflected in the variables passed as arguments in the call.<br>
<br>
<img src="function_by_reference.png" alt=""> <br>
<br>
In fact, <code>a</code>, <code>b</code>, and <code>c</code> become aliases of the arguments passed on the function call (<code>x</code>, <code>y</code>, and <code>z</code>) and any change on <code>a</code> within the function is actually modifying variable <code>x</code> outside the function. Any change on <code>b</code> modifies <code>y</code>, and any change on <code>c</code> modifies <code>z</code>. That is why when, in the example, function <code>duplicate</code> modifies the values of variables <code>a</code>, <code>b</code>, and <code>c</code>, the values of <code>x</code>, <code>y</code>, and <code>z</code> are affected.<br>
<br>
If instead of defining duplicate as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>void</var> duplicate (<var>int</var>&amp; a, <var>int</var>&amp; b, <var>int</var>&amp; c) </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Was it to be defined without the ampersand signs as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>void</var> duplicate (<var>int</var> a, <var>int</var> b, <var>int</var> c)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The variables would not be passed <i>by reference</i>, but <i>by value</i>, creating instead copies of their values. In this case, the output of the program would have been the values of <code>x</code>, <code>y</code>, and <code>z</code> without being modified (i.e., 1, 3, and 7).<br>
</section>
<br>
<section id="constref">
<h3>Efficiency considerations and const references</h3>
Calling a function with parameters taken by value causes copies of the values to be made. This is a relatively inexpensive operation for fundamental types such as <code>int</code>, but if the parameter is of a large compound type, it may result on certain overhead. For example, consider the following function:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>string concatenate (string a, string b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This function takes two strings as parameters (by value), and returns the result of concatenating them. By passing the arguments by value, the function forces <code>a</code> and <code>b</code> to be copies of the arguments passed to the function when it is called. And if these are long strings, it may mean copying large quantities of data just for the function call.<br>
<br>
But this copy can be avoided altogether if both parameters are made <i>references</i>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>string concatenate (string&amp; a, string&amp; b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Arguments by reference do not require a copy. The function operates directly on (aliases of) the strings passed as arguments, and, at most, it might mean the transfer of certain pointers to the function. In this regard, the version of <code>concatenate</code> taking references is more efficient than the version taking values, since it does not need to copy expensive-to-copy strings.<br>
<br>
On the flip side, functions with reference parameters are generally perceived as functions that modify the arguments passed, because that is why reference parameters are actually for.<br>
<br>
The solution is for the function to guarantee that its reference parameters are not going to be modified by this function. This can be done by qualifying the parameters as constant:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>string concatenate (<var>const</var> string&amp; a, <var>const</var> string&amp; b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
By qualifying them as <code>const</code>, the function is forbidden to modify the values of neither <code>a</code> nor <code>b</code>, but can actually access their values as references (aliases of the arguments), without having to make actual copies of the strings.<br>
<br>
Therefore, <code>const</code> references provide functionality similar to passing arguments by value, but with an increased efficiency for parameters of large types. That is why they are extremely popular in C++ for arguments of compound types. Note though, that for most fundamental types, there is no noticeable difference in efficiency, and in some cases, const references may even be less efficient!<br>
</section>
<br>
<section id="inline">
<h3>Inline functions</h3>
Calling a function generally causes a certain overhead (stacking arguments, jumps, etc...), and thus for very short functions, it may be more efficient to simply insert the code of the function where it is called, instead of performing the process of formally calling a function.<br>
<br>
Preceding a function declaration with the <code>inline</code> specifier informs the compiler that inline expansion is preferred over the usual function call mechanism for a specific function. This does not change at all the behavior of a function, but is merely used to suggest the compiler that the code generated by the function body shall be inserted at each point the function is called, instead of being invoked with a regular function call.<br>
<br>
For example, the concatenate function above may be declared inline as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>inline</var> string concatenate (<var>const</var> string&amp; a, <var>const</var> string&amp; b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This informs the compiler that when <code>concatenate</code> is called, the program prefers the function to be expanded inline, instead of performing a regular call. <code>inline</code> is only specified in the function declaration, not when it is called.<br>
<br>
Note that most compilers already optimize code to generate inline functions when they see an opportunity to improve efficiency, even if not explicitly marked with the <code>inline</code> specifier. Therefore, this specifier merely indicates the compiler that inline is preferred for this function, although the compiler is free to not inline it, and optimize otherwise. In C++, optimization is a task delegated to the compiler, which is free to generate any code for as long as the resulting behavior is the one specified by the code.<br>
</section>
<br>
<section id="defaultvalues">
<h3>Default values in parameters</h3>
In C++, functions can also have optional parameters, for which no arguments are required in the call, in such a way that, for example, a function with three parameters may be called with only two. For this, the function shall include a default value for its last parameter, which is used by the function when called with fewer arguments. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// default values in functions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> divide (<var>int</var> a, <var>int</var> b=2)
{
  <var>int</var> r;
  r=a/b;
  <var>return</var> (r);
}

<var>int</var> main ()
{
  cout &lt;&lt; divide (12) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; divide (20,4) &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6
5</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, there are two calls to function <code>divide</code>. In the first one:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>divide (12)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The call only passes one argument to the function, even though the function has two parameters. In this case, the function assumes the second parameter to be 2 (notice the function definition, which declares its second parameter as <code>int b=2</code>). Therefore, the result is 6.<br>
<br>
In the second call:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>divide (20,4)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The call passes two arguments to the function. Therefore, the default value for <code>b</code> (<code>int b=2</code>) is ignored, and <code>b</code> takes the value passed as argument, that is 4, yielding a result of 5.<br>
</section>
<br>
<section id="declarations">
<h3>Declaring functions</h3>
In C++, identifiers can only be used in expressions once they have been declared. For example, some variable <code>x</code> cannot be used before being declared with a statement, such as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> x;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The same applies to functions. Functions cannot be called before they are declared. That is why, in all the previous examples of functions, the functions were always defined before the <code>main</code> function, which is the function from where the other functions were called. If <code>main</code> were defined before the other functions, this would break the rule that functions shall be declared before being used, and thus would not compile.<br>
<br>
The prototype of a function can be declared without actually defining the function completely, giving just enough details to allow the types involved in a function call to be known. Naturally, the function shall be defined somewhere else, like later in the code. But at least, once declared like this, it can already be called.<br>
<br>
The declaration shall include all types involved (the return type and the type of its arguments), using the same syntax as used in the definition of the function, but replacing the body of the function (the block of statements) with an ending semicolon.<br>
<br>
The parameter list does not need to include the parameter names, but only their types. Parameter names can nevertheless be specified, but they are optional, and do not need to necessarily match those in the function definition. For example, a function called <code>protofunction</code> with two int parameters can be declared with either of these statements:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> protofunction (<var>int</var> first, <var>int</var> second);
<var>int</var> protofunction (<var>int</var>, <var>int</var>);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Anyway, including a name for each parameter always improves legibility of the declaration.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br></code></pre></td>
<td class="source"><pre><code><cite>// declaring functions prototypes</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> odd (<var>int</var> x);
<var>void</var> even (<var>int</var> x);

<var>int</var> main()
{
  <var>int</var> i;
  <var>do</var> {
    cout &lt;&lt; <kbd>"Please, enter number (0 to exit): "</kbd>;
    cin &gt;&gt; i;
    odd (i);
  } <var>while</var> (i!=0);
  <var>return</var> 0;
}

<var>void</var> odd (<var>int</var> x)
{
  <var>if</var> ((x%2)!=0) cout &lt;&lt; <kbd>"It is odd.\n"</kbd>;
  <var>else</var> even (x);
}

<var>void</var> even (<var>int</var> x)
{
  <var>if</var> ((x%2)==0) cout &lt;&lt; <kbd>"It is even.\n"</kbd>;
  <var>else</var> odd (x);
}</code></pre></td>
<td class="output"><pre><samp>Please, enter number (0 to exit): 9
It is odd.
Please, enter number (0 to exit): 6
It is even.
Please, enter number (0 to exit): 1030
It is even.
Please, enter number (0 to exit): 0
It is even.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This example is indeed not an example of efficiency. You can probably write yourself a version of this program with half the lines of code. Anyway, this example illustrates how functions can be declared before its definition:<br>
<br>
The following lines:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>void</var> odd (<var>int</var> a);
<var>void</var> even (<var>int</var> a); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Declare the prototype of the functions. They already contain all what is necessary to call them, their name, the types of their argument, and their return type (<code>void</code> in this case). With these prototype declarations in place, they can be called before they are entirely defined, allowing for example, to place the function from where they are called (<code>main</code>)  before the actual definition of these functions.<br>
<br>
But declaring functions before being defined is not only useful to reorganize the order of functions within the code. In some cases, such as in this particular case, at least one of the declarations is required, because <code>odd</code> and <code>even</code> are mutually called; there is a call to <code>even</code> in <code>odd</code> and a call to <code>odd</code> in <code>even</code>. And, therefore, there is no way to structure the code so that <code>odd</code> is defined before <code>even</code>, and <code>even</code> before <code>odd</code>.<br>
</section>
<br>
<section id="recursivity">
<h3>Recursivity</h3>
Recursivity is the property that functions have to be called by themselves. It is useful for some tasks, such as sorting elements, or calculating the factorial of numbers. For example, in order to obtain the factorial of a number (<code>n!</code>) the mathematical formula would be:<br>
<br>
<code>n! = n * (n-1) * (n-2) * (n-3) ... * 1</code>
<br>
More concretely, <code>5!</code> (factorial of 5) would be:<br>
<br>
<code>5! = 5 * 4 * 3 * 2 * 1 = 120</code>
<br>
And a recursive function to calculate this in C++ could be:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><cite>// factorial calculator</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>long</var> factorial (<var>long</var> a)
{
  <var>if</var> (a &gt; 1)
   <var>return</var> (a * factorial (a-1));
  <var>else</var>
   <var>return</var> 1;
}

<var>int</var> main ()
{
  <var>long</var> number = 9;
  cout &lt;&lt; number &lt;&lt; <kbd>"! = "</kbd> &lt;&lt; factorial (number);
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>9! = 362880</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice how in function factorial we included a call to itself, but only if the argument passed was greater than 1, since, otherwise, the function would perform an infinite recursive loop, in which once it arrived to 0, it would continue multiplying by all the negative numbers (probably provoking a stack overflow at some point during runtime).<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="../control/index.html" rel="prev"><img src="https://www.cplusplus.com/ico/32arrowleft.png" width="32" height="32" alt="Previous">Previous:<br><b>Statements and flow control</b></a></td><td class="index"><a href="../index.html" rel="index"><img src="https://www.cplusplus.com/ico/32doc.png" width="32" height="32" alt="Index"><br>Index</a></td><td class="next"><a href="../functions2/index.html" rel="next"><img src="https://www.cplusplus.com/ico/32arrowright.png" width="32" height="32" alt="Next">Next:<br><b>Overloads and templates</b></a></td></tr></table></div><div id="CH_bb"></div></div>
<div class="C_support">
<div id='div-gpt-ad-1593433023017-0' style='width: 728px; height: 90px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1593433023017-0'); });
  </script>
</div>
</div></div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="https://www.cplusplus.com/">C++</a></b></h3>
<ul>
<li class="folder info"><a href="https://www.cplusplus.com/info/">Information</a></li>
<li class="folder selected doc"><a href="https://www.cplusplus.com/doc/">Tutorials</a></li>
<li class="folder reference"><a href="https://www.cplusplus.com/reference/">Reference</a></li>
<li class="folder articles"><a href="https://www.cplusplus.com/articles/">Articles</a></li>
<li class="folder forum"><a href="https://www.cplusplus.com/forum/">Forum</a></li>
</ul>
</div>
<div class="C_BoxLabels C_BoxSort sect" id="doc_box">
<h3><b><a href="https://www.cplusplus.com/doc/">Tutorials</a></b></h3>
<ul>
<li class="cpp98 cpp11 selected folder"><a href="../index.html"><span>C++ Language</span></a></li>
<li><a href="https://www.cplusplus.com/doc/ascii/"><span>Ascii Codes</span></a></li>
<li><a href="https://www.cplusplus.com/doc/boolean/"><span>Boolean Operations</span></a></li>
<li><a href="https://www.cplusplus.com/doc/hex/"><span>Numerical Bases</span></a></li>
</ul>
</div>
<div class="C_BoxLabels C_BoxSort sect cpp98 cpp11" id="tutorial_box">
<h3><b><a href="../index.html">C++ Language</a></b></h3>
<ul>
<li class="C_Collapsable"><h4>Introduction:</h4><ul>
<li class="folder"><a href="../introduction/index.html"><span>Compilers</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Basics of C++:</h4><ul>
<li><a href="../program_structure/index.html"><span>Structure of a program</span></a></li>
<li><a href="../variables/index.html"><span>Variables and types</span></a></li>
<li><a href="../constants/index.html"><span>Constants</span></a></li>
<li><a href="../operators/index.html"><span>Operators</span></a></li>
<li><a href="../basic_io/index.html"><span>Basic Input/Output</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Program structure:</h4><ul>
<li><a href="../control/index.html"><span>Statements and flow control</span></a></li>
<li class="selected"><a href="index.html"><span>Functions</span></a></li>
<li><a href="../functions2/index.html"><span>Overloads and templates</span></a></li>
<li><a href="../namespaces/index.html"><span>Name visibility</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Compound data types:</h4><ul>
<li><a href="../arrays/index.html"><span>Arrays</span></a></li>
<li><a href="../ntcs/index.html"><span>Character sequences</span></a></li>
<li><a href="../pointers/index.html"><span>Pointers</span></a></li>
<li><a href="../dynamic/index.html"><span>Dynamic memory</span></a></li>
<li><a href="../structures/index.html"><span>Data structures</span></a></li>
<li><a href="../other_data_types/index.html"><span>Other data types</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Classes:</h4><ul>
<li><a href="../classes/index.html"><span>Classes (I)</span></a></li>
<li><a href="../templates/index.html"><span>Classes (II)</span></a></li>
<li><a href="../classes2/index.html"><span>Special members</span></a></li>
<li><a href="../inheritance/index.html"><span>Friendship and inheritance</span></a></li>
<li><a href="../polymorphism/index.html"><span>Polymorphism</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Other language features:</h4><ul>
<li><a href="../typecasting/index.html"><span>Type conversions</span></a></li>
<li><a href="../exceptions/index.html"><span>Exceptions</span></a></li>
<li><a href="../preprocessor/index.html"><span>Preprocessor directives</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Standard library:</h4><ul>
<li><a href="../files/index.html"><span>Input/output with files</span></a></li>
</ul></li>
</ul>
</div>
<div id="I_subnav"></div>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<p>
<ins class="adsbygoogle"
     style="display:inline-block;width:234px;height:60px"
     data-ad-client="ca-pub-1444228343479937"
     data-ad-slot="3817422056"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="https://www.cplusplus.com/">Home page</a> | <a href="https://www.cplusplus.com/privacy.do">Privacy policy</a><br>&copy; cplusplus.com, 2000-2021 - All rights reserved - <i>v3.2</i><br><a href="https://www.cplusplus.com/contact.do?referrer=www.cplusplus.com%2Fdoc%2Ftutorial%2Ffunctions%2F">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
 onSession ( function(us) {
		el=document.getElementById('CH_bb'); el.innerHTML='';
		if (us.auth(4096)) {
			
			el.appendChild(btn('Edit Page','Edit Page','edit','https://www.cplusplus.com/doc/edit.cgi?a=tutorial+functions'));
			el.appendChild(btn('Delete Page','Delete Page','delete','javascript:docdel()'));
		}
	});
	function docdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='https://www.cplusplus.com/doc/delete.cgi?a=tutorial+functions'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

<script>
(function(){
  // mini cookie-consent code (c) Juan Soulie, 2016
  var s ='consent=cookie';
  var e = document.createElement('div');
  e.innerHTML = '<div style="background:#eed;padding:10px;margin:0;text-align:center;border-bottom:1px solid #446"><span style="color:#210;font-weight:bold">This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our <a href="/privacy.do">privacy policy</a>.</span> <span style="margin-left:10px;border-radius:5px;padding:1px 10px;background:#bcd;border:1px solid #789;cursor:pointer">ok</span></div>';
  if (document.cookie.indexOf(s)!==-1) return;
  var b = document.getElementsByTagName('body')[0];
  b.insertBefore(e,b.firstChild);
  var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };
  e.addEventListener('click',x);
  document.addEventListener('scroll',x);
})();
</script>

</body>

<!-- Mirrored from www.cplusplus.com/doc/tutorial/functions/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Jul 2021 12:46:35 GMT -->
</html>