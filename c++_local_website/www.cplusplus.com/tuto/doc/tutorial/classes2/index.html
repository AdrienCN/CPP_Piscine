<!DOCTYPE html>
<html>

<!-- Mirrored from www.cplusplus.com/doc/tutorial/classes2/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Jul 2021 12:46:52 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Special members - C++ Tutorials</title>
<link rel="canonical" href="index.html">
<link rel="shortcut icon" type="image/x-icon" href="https://www.cplusplus.com/favicon.ico">
<link rel="stylesheet" type="text/css" href="https://www.cplusplus.com/v322/main.css">
<script src="https://www.cplusplus.com/v322/main.js" type="text/javascript"></script>
<script async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script>
<script>
  window.googletag = window.googletag || {cmd: []};
  googletag.cmd.push(function() {
    googletag.defineSlot('/147246189/cplusplus.com_728x90_leaderboard_1', [728, 90], 'div-gpt-ad-1593433023017-0').addService(googletag.pubads());
    googletag.defineSlot('/147246189/cplusplus.com_234x120_sidebar_1', [234, 60], 'cplusplus.com_234x120_sidebar_1').addService(googletag.pubads());
    googletag.pubads().enableSingleRequest();
    googletag.pubads().disableInitialLoad();
    googletag.enableServices();
  });
</script>
<script src="https://cloud.setupad.com/hb/cpluspluscom.js" async></script>
<script src="https://c.aaxads.com/aax.js?pub=AAX5H4CNQ&amp;hst=www.cplusplus.com&amp;ver=1.2" async></script></head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="https://www.cplusplus.com/" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="https://www.cplusplus.com/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="https://www.cplusplus.com/doc/">Tutorials</a></li>
<li><a href="../index.html">C++ Language</a></li>
<li class="here">Special members</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div class="C_support">
<div id='div-gpt-ad-1593433023017-0' style='width: 728px; height: 90px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1593433023017-0'); });
  </script>
</div>
</div><div id="I_content">
<div class="C_doc">
<h1>Special members</h1>
<section id="special_member_functions">
[NOTE: This chapter requires proper understanding of <i><a href="../dynamic/index.html">dynamically allocated memory</a></i>]<br>
<br>
<dfn>Special member functions</dfn> are member functions that are implicitly defined as member of classes under certain circumstances. There are six:<br>
<br>
<table class="boxed"><tr><th>Member function</th><th>typical form for class <code>C</code>:</th></tr>
<tr><td><a href="#default_constructor">Default constructor</a></td><td><code>C::C();</code></td></tr>
<tr><td><a href="#destructor">Destructor</a></td><td><code>C::~C();</code></td></tr>
<tr><td><a href="#copy_constructor">Copy constructor</a></td><td><code>C::C (const C&);</code></td></tr>
<tr><td><a href="#copy_assignment">Copy assignment</a></td><td><code>C& operator= (const C&);</code></td></tr>
<tr><td><a href="#move">Move constructor</a></td><td><code>C::C (C&&);</code></td></tr>
<tr><td><a href="#move">Move assignment</a></td><td><code>C& operator= (C&&);</code></td></tr>
</table>
<br>
Let's examine each of these:<br>
</section>
<br>
<section id="default_constructor">
<h3>Default constructor</h3>
The <dfn>default constructor</dfn> is the constructor called when objects of a class are declared, but are not initialized with any arguments.<br>
<br>
If a class definition has no constructors, the compiler assumes the class to have an implicitly defined <i>default constructor</i>. Therefore, after declaring a class like this:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Example {
  <var>public</var>:
    <var>int</var> total;
    <var>void</var> accumulate (<var>int</var> x) { total += x; }
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The compiler assumes that <code>Example</code> has a <i>default constructor</i>. Therefore, objects of this class can be constructed by simply declaring them without any arguments:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example ex;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
But as soon as a class has some constructor taking any number of parameters explicitly declared, the compiler no longer provides an implicit default constructor, and no longer allows the declaration of new objects of that class without arguments. For example, the following class:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Example2 {
  <var>public</var>:
    <var>int</var> total;
    Example2 (<var>int</var> initial_value) : total(initial_value) { };
    <var>void</var> accumulate (<var>int</var> x) { total += x; };
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, we have declared a constructor with a parameter of type <code>int</code>. Therefore the following object declaration would be correct:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example2 ex (100);   <cite>// ok: calls constructor </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
But the following:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example2 ex;         <cite>// not valid: no default constructor </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Would not be valid, since the class has been declared with an explicit constructor taking one argument and that replaces the implicit <i>default constructor</i> taking none.<br>
<br>
Therefore, if objects of this class need to be constructed without arguments, the proper <i>default constructor</i> shall also be declared in the class. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// classes and default constructors</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example3 {
    string data;
  <var>public</var>:
    Example3 (<var>const</var> string&amp; str) : data(str) {}
    Example3() {}
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> data;}
};

<var>int</var> main () {
  Example3 foo;
  Example3 bar (<kbd>"Example"</kbd>);

  cout &lt;&lt; <kbd>"bar's content: "</kbd> &lt;&lt; bar.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>Example3</code> has a <i>default constructor</i> (i.e., a constructor without parameters) defined as an empty block:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example3() {}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This allows objects of class <code>Example3</code> to be constructed without arguments (like <code>foo</code> was declared in this example). Normally, a default constructor like this is implicitly defined for all classes that have no other constructors and thus no explicit definition is required. But in this case, <code>Example3</code> has another constructor:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example3 (<var>const</var> string&amp; str);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
And when any constructor is explicitly declared in a class, no implicit <i>default constructors</i> is automatically provided.<br>
</section>
<br>
<section id="destructor">
<h3>Destructor</h3>
Destructors fulfill the opposite functionality of <i>constructors</i>: They are responsible for the necessary cleanup needed by a class when its lifetime ends. The classes we have defined in previous chapters did not allocate any resource and thus did not really require any clean up.<br>
<br>
But now, let's imagine that the class in the last example allocates dynamic memory to store the string it had as data member; in this case, it would be very useful to have a function called automatically at the end of the object's life in charge of releasing this memory. To do this, we use a <i>destructor</i>. A destructor is a member function very similar to a <i>default constructor</i>: it takes no arguments and returns nothing, not even <code>void</code>. It also uses the class name as its own name, but preceded with a tilde sign (<code>~</code>):<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><cite>// destructors</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example4 {
    string* ptr;
  <var>public</var>:
    <cite>// constructors:</cite>
    Example4() : ptr(<var>new</var> string) {}
    Example4 (<var>const</var> string&amp; str) : ptr(<var>new</var> string(str)) {}
    <cite>// destructor:</cite>
    ~Example4 () {<var>delete</var> ptr;}
    <cite>// access content:</cite>
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> *ptr;}
};

<var>int</var> main () {
  Example4 foo;
  Example4 bar (<kbd>"Example"</kbd>);

  cout &lt;&lt; <kbd>"bar's content: "</kbd> &lt;&lt; bar.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
On construction, <code>Example4</code> allocates storage for a <code>string</code>. Storage that is later released by the destructor.<br>
<br>
The destructor for an object is called at the end of its lifetime; in the case of <code>foo</code> and <code>bar</code> this happens at the end of function <code>main</code>.<br>
</section>
<br>
<section id="copy_constructor">
<h3>Copy constructor</h3>
When an object is passed a named object of its own type as argument, its <i>copy constructor</i> is invoked in order to construct a copy.<br>
<br>
A <i>copy constructor</i> is a constructor whose first parameter is of type <i>reference to the class</i> itself (possibly <code>const</code> qualified) and which can be invoked with a single argument of this type. For example, for a class <code>MyClass</code>, the <i>copy constructor</i> may have the following signature:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>MyClass::MyClass (<var>const</var> MyClass&amp;);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If a class has no custom <i>copy</i> nor <i>move</i> constructors (or assignments) defined, an implicit <i>copy constructor</i> is provided. This copy constructor simply performs a copy of its own members. For example, for a class such as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>class</var> MyClass {
  <var>public</var>:
    <var>int</var> a, b; string c;
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
An implicit <i>copy constructor</i> is automatically defined. The definition assumed for this function performs a <i>shallow copy</i>, roughly equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>MyClass::MyClass(<var>const</var> MyClass&amp; x) : a(x.a), b(x.b), c(x.c) {}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This default <i>copy constructor</i> may suit the needs of many classes. But <i>shallow copies</i> only copy the members of the class themselves, and this is probably not what we expect for classes like class <code>Example4</code> we defined above, because it contains pointers of which it handles its storage. For that class, performing a <i>shallow copy</i> means that the pointer value is copied, but not the content itself; This means that both objects (the copy and the original) would be sharing a single <code>string</code> object (they would both be pointing to the same object), and at some point (on destruction) both objects would try to delete the same block of memory, probably causing the program to crash on runtime. This can be solved by defining the following custom <i>copy constructor</i> that performs a <i>deep copy</i>:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></code></pre></td>
<td class="source"><pre><code><cite>// copy constructor: deep copy</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example5 {
    string* ptr;
  <var>public</var>:
    Example5 (<var>const</var> string&amp; str) : ptr(<var>new</var> string(str)) {}
    ~Example5 () {<var>delete</var> ptr;}
    <cite>// copy constructor:</cite>
    Example5 (<var>const</var> Example5&amp; x) : ptr(<var>new</var> string(x.content())) {}
    <cite>// access content:</cite>
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> *ptr;}
};

<var>int</var> main () {
  Example5 foo (<kbd>"Example"</kbd>);
  Example5 bar = foo;

  cout &lt;&lt; <kbd>"bar's content: "</kbd> &lt;&lt; bar.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The <i>deep copy</i> performed by this <i>copy constructor</i> allocates storage for a new string, which is initialized to contain a copy of the original object. In this way, both objects (copy and original) have distinct copies of the content stored in different locations.<br>
</section>
<br>
<section id="copy_assignment">
<h3>Copy assignment</h3>
Objects are not only copied on construction, when they are initialized: They can also be copied on any assignment operation. See the difference:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>MyClass foo;
MyClass bar (foo);       <cite>// object initialization: copy constructor called</cite>
MyClass baz = foo;       <cite>// object initialization: copy constructor called</cite>
foo = bar;               <cite>// object already initialized: copy assignment called </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that <code>baz</code> is initialized on construction using an <i>equal sign</i>, but this is not an assignment operation! (although it may look like one): The declaration of an object is not an assignment operation, it is just another of the syntaxes to call single-argument constructors.<br>
<br>
The assignment on <code>foo</code> is an assignment operation. No object is being declared here, but an operation is being performed on an existing object; <code>foo</code>.<br>
<br>
The <i>copy assignment operator</i> is an overload of <code>operator=</code> which takes a <i>value</i> or <i>reference</i> of the class itself as parameter. The return value is generally a reference to <code>*this</code> (although this is not required). For example, for a class <code>MyClass</code>, the <i>copy assignment</i> may have the following signature:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>MyClass&amp; <var>operator</var>= (<var>const</var> MyClass&amp;);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The <i>copy assignment operator</i> is also a <i>special function</i> and is also defined implicitly if a class has no custom <i>copy</i> nor <i>move</i> assignments (nor move constructor) defined.<br>
<br>
But again, the <i>implicit</i> version performs a <i>shallow copy</i> which is suitable for many classes, but not for classes with pointers to objects they handle its storage, as is the case in <code>Example5</code>. In this case, not only the class incurs the risk of deleting the pointed object twice, but the assignment creates memory leaks by not deleting the object pointed by the object before the assignment. These issues could be solved with a <i>copy assignment</i> that deletes the previous object and performs a <i>deep copy</i>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>Example5&amp; <var>operator</var>= (<var>const</var> Example5&amp; x) {
  <var>delete</var> ptr;                      <cite>// delete currently pointed string</cite>
  ptr = <var>new</var> string (x.content());  <cite>// allocate space for new string, and copy</cite>
  <var>return</var> *<var>this</var>;
}
</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Or even better, since its <code>string</code> member is not constant, it could re-utilize the same <code>string</code> object:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>Example5&amp; <var>operator</var>= (<var>const</var> Example5&amp; x) {
  *ptr = x.content();
  <var>return</var> *<var>this</var>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
</section>
<br>
<section id="move">
<h3>Move constructor and assignment</h3>
Similar to copying, moving also uses the value of an object to set the value to another object. But, unlike copying, the content is actually transferred from one object (the source) to the other (the destination): the source loses that content, which is taken over by the destination. This moving only happens when the source of the value is an <i>unnamed object</i>. <br>
<br>
<i>Unnamed objects</i> are objects that are temporary in nature, and thus haven't even been given a name. Typical examples of <i>unnamed objects</i> are return values of functions or type-casts.<br>
<br>
Using the value of a temporary object such as these to initialize another object or to assign its value, does not really require a copy: the object is never going to be used for anything else, and thus, its value can be <i>moved into</i> the destination object. These cases trigger the <i>move constructor</i> and <i>move assignments</i>:<br>
<br>
The <i>move constructor</i> is called when an object is initialized on construction using an unnamed temporary. Likewise, the <i>move assignment</i> is called when an object is assigned the value of an unnamed temporary:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>MyClass fn();            <cite>// function returning a MyClass object</cite>
MyClass foo;             <cite>// default constructor</cite>
MyClass bar = foo;       <cite>// copy constructor</cite>
MyClass baz = fn();      <cite>// move constructor</cite>
foo = bar;               <cite>// copy assignment</cite>
baz = MyClass();         <cite>// move assignment </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both the value returned by <code>fn</code> and the value constructed with <code>MyClass</code> are unnamed temporaries. In these cases, there is no need to make a copy, because the unnamed object is very short-lived and can be acquired by the other object when this is a more efficient operation.<br>
<br>
The move constructor and move assignment are members that take a parameter of type <i>rvalue reference to the class</i> itself:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>MyClass (MyClass&amp;&amp;);             <cite>// move-constructor</cite>
MyClass&amp; <var>operator</var>= (MyClass&amp;&amp;);  <cite>// move-assignment </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
An <i>rvalue reference</i> is specified by following the type with two ampersands (<code>&&</code>). As a parameter, an <i>rvalue reference</i> matches arguments of temporaries of this type.<br>
<br>
The concept of moving is most useful for objects that manage the storage they use, such as objects that allocate storage with new and delete. In such objects, copying and moving are really different operations:<br>
- Copying from A to B means that new memory is allocated to B and then the entire content of A is copied to this new memory allocated for B.<br>
- Moving from A to B means that the memory already allocated to A is transferred to B without allocating any new storage. It involves simply copying the pointer.<br>
<br>
For example:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br></code></pre></td>
<td class="source"><pre><code><cite>// move constructor/assignment</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example6 {
    string* ptr;
  <var>public</var>:
    Example6 (<var>const</var> string&amp; str) : ptr(<var>new</var> string(str)) {}
    ~Example6 () {<var>delete</var> ptr;}
    <cite>// move constructor</cite>
    Example6 (Example6&amp;&amp; x) : ptr(x.ptr) {x.ptr=<var>nullptr</var>;}
    <cite>// move assignment</cite>
    Example6&amp; <var>operator</var>= (Example6&amp;&amp; x) {
      <var>delete</var> ptr; 
      ptr = x.ptr;
      x.ptr=<var>nullptr</var>;
      <var>return</var> *<var>this</var>;
    }
    <cite>// access content:</cite>
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> *ptr;}
    <cite>// addition:</cite>
    Example6 <var>operator</var>+(<var>const</var> Example6&amp; rhs) {
      <var>return</var> Example6(content()+rhs.content());
    }
};


<var>int</var> main () {
  Example6 foo (<kbd>"Exam"</kbd>);
  Example6 bar = Example6(<kbd>"ple"</kbd>);   <cite>// move-construction</cite>
  
  foo = foo + bar;                  <cite>// move-assignment</cite>

  cout &lt;&lt; <kbd>"foo's content: "</kbd> &lt;&lt; foo.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>foo's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Compilers already optimize many cases that formally require a move-construction call in what is known as <i>Return Value Optimization</i>. Most notably, when the value returned by a function is used to initialize an object. In these cases, the <i>move constructor</i> may actually never get called.<br>
<br>
Note that even though <i>rvalue references</i> can be used for the type of any function parameter, it is seldom useful for uses other than the <i>move constructor</i>. Rvalue references are tricky, and unnecessary uses may be the source of errors quite difficult to track.<br>
</section>
<br>
<section id="implicit">
<h3>Implicit members</h3>
The six <i>special members functions</i> described above are members implicitly declared on classes under certain circumstances:<br>
<br>
<table class="boxed"><tr><th>Member function</th><th>implicitly defined:</th><th>default definition:</th></tr>
<tr><td><a href="#default_constructor">Default constructor</a></td><td>if no other constructors</td><td>does nothing</td></tr>
<tr><td><a href="#destructor">Destructor</a></td><td>if no destructor</td><td>does nothing</td></tr>
<tr><td><a href="#copy_constructor">Copy constructor</a></td><td>if no move constructor and no move assignment</td><td>copies all members</td></tr>
<tr><td><a href="#copy_assignment">Copy assignment</a></td><td>if no move constructor and no move assignment</td><td>copies all members</td></tr>
<tr><td><a href="#move">Move constructor</a></td><td>if no destructor, no copy constructor and no copy nor move assignment</td><td>moves all members</td></tr>
<tr><td><a href="#move">Move assignment</a></td><td>if no destructor, no copy constructor and no copy nor move assignment</td><td>moves all members</td></tr>
</table>
<br>
Notice how not all <i>special member functions</i> are implicitly defined in the same cases. This is mostly due to backwards compatibility with C structures and earlier C++ versions, and in fact some include deprecated cases. Fortunately, each class can select explicitly which of these members exist with their default definition or which are deleted by using the keywords <code>default</code> and <code>delete</code>, respectively. The syntax is either one of:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>
function_declaration = default;
function_declaration = delete;
</samp></pre></td></tr></table></div>
<br>
For example:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// default and delete implicit members</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    Rectangle (<var>int</var> x, <var>int</var> y) : width(x), height(y) {}
    Rectangle() = <var>default</var>;
    Rectangle (<var>const</var> Rectangle&amp; other) = <var>delete</var>;
    <var>int</var> area() {<var>return</var> width*height;}
};

<var>int</var> main () {
  Rectangle foo;
  Rectangle bar (10,20);

  cout &lt;&lt; <kbd>"bar's area: "</kbd> &lt;&lt; bar.area() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's area: 200</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>Rectangle</code> can be constructed either with two <code>int</code> arguments or be <i>default-constructed</i> (with no arguments). It cannot however be <i>copy-constructed</i> from another <code>Rectangle</code> object, because this function has been deleted. Therefore, assuming the objects of the last example, the following statement would not be valid:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle baz (foo);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It could, however, be made explicitly valid by defining its copy constructor as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle::Rectangle (<var>const</var> Rectangle&amp; other) = <var>default</var>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Which would be essentially equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle::Rectangle (<var>const</var> Rectangle&amp; other) : width(other.width), height(other.height) {}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that, the keyword <code>default</code> does not define a member function equal to the <i>default constructor</i> (i.e., where <i>default constructor</i> means constructor with no parameters), but equal to the constructor that would be implicitly defined if not deleted.<br>
<br>
In general, and for future compatibility, classes that explicitly define one copy/move constructor or one copy/move assignment but not both, are encouraged to specify either <code>delete</code> or <code>default</code> on the other special member functions they don't explicitly define.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="../templates/index.html" rel="prev"><img src="https://www.cplusplus.com/ico/32arrowleft.png" width="32" height="32" alt="Previous">Previous:<br><b>Classes (II)</b></a></td><td class="index"><a href="../index.html" rel="index"><img src="https://www.cplusplus.com/ico/32doc.png" width="32" height="32" alt="Index"><br>Index</a></td><td class="next"><a href="../inheritance/index.html" rel="next"><img src="https://www.cplusplus.com/ico/32arrowright.png" width="32" height="32" alt="Next">Next:<br><b>Friendship and inheritance</b></a></td></tr></table></div><div id="CH_bb"></div></div>
<div class="C_support">
<div id='div-gpt-ad-1593433023017-0' style='width: 728px; height: 90px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1593433023017-0'); });
  </script>
</div>
</div></div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="https://www.cplusplus.com/">C++</a></b></h3>
<ul>
<li class="folder info"><a href="https://www.cplusplus.com/info/">Information</a></li>
<li class="folder selected doc"><a href="https://www.cplusplus.com/doc/">Tutorials</a></li>
<li class="folder reference"><a href="https://www.cplusplus.com/reference/">Reference</a></li>
<li class="folder articles"><a href="https://www.cplusplus.com/articles/">Articles</a></li>
<li class="folder forum"><a href="https://www.cplusplus.com/forum/">Forum</a></li>
</ul>
</div>
<div class="C_BoxLabels C_BoxSort sect" id="doc_box">
<h3><b><a href="https://www.cplusplus.com/doc/">Tutorials</a></b></h3>
<ul>
<li class="cpp98 cpp11 selected folder"><a href="../index.html"><span>C++ Language</span></a></li>
<li><a href="https://www.cplusplus.com/doc/ascii/"><span>Ascii Codes</span></a></li>
<li><a href="https://www.cplusplus.com/doc/boolean/"><span>Boolean Operations</span></a></li>
<li><a href="https://www.cplusplus.com/doc/hex/"><span>Numerical Bases</span></a></li>
</ul>
</div>
<div class="C_BoxLabels C_BoxSort sect cpp98 cpp11" id="tutorial_box">
<h3><b><a href="../index.html">C++ Language</a></b></h3>
<ul>
<li class="C_Collapsable"><h4>Introduction:</h4><ul>
<li class="folder"><a href="../introduction/index.html"><span>Compilers</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Basics of C++:</h4><ul>
<li><a href="../program_structure/index.html"><span>Structure of a program</span></a></li>
<li><a href="../variables/index.html"><span>Variables and types</span></a></li>
<li><a href="../constants/index.html"><span>Constants</span></a></li>
<li><a href="../operators/index.html"><span>Operators</span></a></li>
<li><a href="../basic_io/index.html"><span>Basic Input/Output</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Program structure:</h4><ul>
<li><a href="../control/index.html"><span>Statements and flow control</span></a></li>
<li><a href="../functions/index.html"><span>Functions</span></a></li>
<li><a href="../functions2/index.html"><span>Overloads and templates</span></a></li>
<li><a href="../namespaces/index.html"><span>Name visibility</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Compound data types:</h4><ul>
<li><a href="../arrays/index.html"><span>Arrays</span></a></li>
<li><a href="../ntcs/index.html"><span>Character sequences</span></a></li>
<li><a href="../pointers/index.html"><span>Pointers</span></a></li>
<li><a href="../dynamic/index.html"><span>Dynamic memory</span></a></li>
<li><a href="../structures/index.html"><span>Data structures</span></a></li>
<li><a href="../other_data_types/index.html"><span>Other data types</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Classes:</h4><ul>
<li><a href="../classes/index.html"><span>Classes (I)</span></a></li>
<li><a href="../templates/index.html"><span>Classes (II)</span></a></li>
<li class="selected"><a href="index.html"><span>Special members</span></a></li>
<li><a href="../inheritance/index.html"><span>Friendship and inheritance</span></a></li>
<li><a href="../polymorphism/index.html"><span>Polymorphism</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Other language features:</h4><ul>
<li><a href="../typecasting/index.html"><span>Type conversions</span></a></li>
<li><a href="../exceptions/index.html"><span>Exceptions</span></a></li>
<li><a href="../preprocessor/index.html"><span>Preprocessor directives</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Standard library:</h4><ul>
<li><a href="../files/index.html"><span>Input/output with files</span></a></li>
</ul></li>
</ul>
</div>
<div id="I_subnav"></div>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<p>
<ins class="adsbygoogle"
     style="display:inline-block;width:234px;height:60px"
     data-ad-client="ca-pub-1444228343479937"
     data-ad-slot="3817422056"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="https://www.cplusplus.com/">Home page</a> | <a href="https://www.cplusplus.com/privacy.do">Privacy policy</a><br>&copy; cplusplus.com, 2000-2021 - All rights reserved - <i>v3.2</i><br><a href="https://www.cplusplus.com/contact.do?referrer=www.cplusplus.com%2Fdoc%2Ftutorial%2Fclasses2%2F">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
 onSession ( function(us) {
		el=document.getElementById('CH_bb'); el.innerHTML='';
		if (us.auth(4096)) {
			
			el.appendChild(btn('Edit Page','Edit Page','edit','https://www.cplusplus.com/doc/edit.cgi?a=tutorial+classes2'));
			el.appendChild(btn('Delete Page','Delete Page','delete','javascript:docdel()'));
		}
	});
	function docdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='https://www.cplusplus.com/doc/delete.cgi?a=tutorial+classes2'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

<script>
(function(){
  // mini cookie-consent code (c) Juan Soulie, 2016
  var s ='consent=cookie';
  var e = document.createElement('div');
  e.innerHTML = '<div style="background:#eed;padding:10px;margin:0;text-align:center;border-bottom:1px solid #446"><span style="color:#210;font-weight:bold">This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our <a href="/privacy.do">privacy policy</a>.</span> <span style="margin-left:10px;border-radius:5px;padding:1px 10px;background:#bcd;border:1px solid #789;cursor:pointer">ok</span></div>';
  if (document.cookie.indexOf(s)!==-1) return;
  var b = document.getElementsByTagName('body')[0];
  b.insertBefore(e,b.firstChild);
  var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };
  e.addEventListener('click',x);
  document.addEventListener('scroll',x);
})();
</script>

</body>

<!-- Mirrored from www.cplusplus.com/doc/tutorial/classes2/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Jul 2021 12:46:52 GMT -->
</html>